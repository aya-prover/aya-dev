open import Arith::Nat
open import Data::List

prim SourcePos: Type
prim TAC_STATE: Type
prim Str: Type
def Name: Type => Str

struct FailureData: Type
| sourcePos: SourcePos
| reason: Str

open data Exceptional (A: Type): Type
| success A
| failure Str --- error result can be more verbose

open data TacResult (State: Type) (Ty: Type): Type
| tacSucc State Ty
| tacFail FailureData State

module InteractMonad {
  def M (State: Type) (Ty: Type): Type => State -> TacResult State Ty

  def execute {State} (f: Ty1 -> M Ty2) (prev : TacResult S Ty1) : TacResult State Ty2
  | _, tacFail failData s => tacFail failData s
  | f, tacSucc state tm => f tm

  def infixr >>= {Ty1 Ty2} (m1 : M S Ty1) (f : Ty1 -> M S Ty2) : M S Ty2 => \s. => execute f (m1 s)

  def pure {Ty} (tm : Ty) : M S Ty => \s. tacSucc s x

  def empty {S Ty} : M S Ty => \s. tacFail (new {sourcePos := NONE, reason := "empty"}) s

  def choose {S Ty} (res1 res2 : TacResult S Ty): TacResult S Ty
  | tacSucc s ty, _ => tacSucc s Ty
  | tacFail _ _, tacSucc s tm => tacSucc s tm
  | tacFail failData s, tacFail _ _ => tacFail failData s

  def infixl <|> {S Ty} (m1 m2 : M S Ty) : M S Ty => \s. choose (m1 s) (m2 s)
}

def TacM (Ty: Type): Type => InteractMonad.M TAC_STATE Ty

def infixl <|> {S Ty} (m1 m2: TacM S Ty): TacM S Ty => InteractMonad.(<|>)

def infixr >>= {Ty1 Ty2} (m1 : TacM S Ty1) (f : Ty1 -> TacM S Ty2)  => InteractMonad.(>>=)

def fail {Ty} (str : Str): TacM Ty => \s. => tacFail (new {sourcePos := NONE, reason := str}) s

def getDecl:

@Internal
open module PrimMethods {
  prim getDecl: Name -> TacM Decl
  prim addDecl: Decl -> TacM Unit
  def getConNames: Name -> List Name
  def getConExps: Name -> Name -> Term
  def getGoals: TacM (List Term)
  def getFirstGoal: TacM Term
  def getRestGoal: TacM (List Term)
  def setGoals: List Term -> TacM Unit
  def hasGoal: TacM Bool
  def QED: TacM Unit
  ------
  def infer: Term -> TacM Term
  def unify: Term -> Term -> TacM Unit
  def intro: Term
  -------
  -- def printGoals: TacM Str
}

-- when a term is elaborated,

-- TODO: bulletin syntax

tacdef focus {Ty} (tac: TacM Ty): TacM Ty =>
  do g <- getFirstGoal
          gs <- getRestGoals
          setGoals [g] -- TODO: list syntax
          a <- tac
          newGs <- getGoals
          setGoals (newGoals ++ gs)
          return a

tacdef attackAll {Ty} (tac: TacM Ty): TacM (List Ty) =>
  do gs <- getGoals
     go gs []
     where def go: List Term -> List Term -> TacM (List Ty) =>
           | nil, new_gs => do setGoals new_gs
                               return nil
           | g <: gs, new_gs => do setGoals [g]
                                   a <- tac
                                   new_gs' <- getGoals
                                   as <- go gs (new_gs' ++ new_gs) -- memorizing generated goals
