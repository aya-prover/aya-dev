open data Nat: Type
| zero
| suc Nat

def overlap infixl + (a b : Nat) : Nat
| zero, a => a
| a, zero => a
| suc a, b => suc (a + b)
| a, suc b => suc (a + b)

def overlap infixl *' (m n : Nat) : Nat
| zero, n => zero
| m, zero => zero
| suc m, suc n => suc (m + n + m *' n)
bind tighter +

open data List (A: Type): Type
| nil
| cons A (List A)

def gen (n: Nat): List Nat
| zero => nil
| suc n => cons (suc n) (gen n)

def foldr {A B: Type} (f: A -> B -> B) (z: B) (l: List A): B
| f, z, nil => z
| f, z, cons x xs => f x (foldr f z xs)

def tails {A: Type} (l: List A): List (List A)
| nil => cons nil nil
| cons x xs => cons xs (tails xs)

def map {A B: Type} (f: A -> B) (l: List A): List B
| f, nil => nil
| f, cons x xs => cons (f x) (map f xs)

def head (l: List Nat): Nat
| nil => zero
| cons x xs => x

def ten: Nat => (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc zero))))))))))

def hundred: Nat => ten *' ten

def thousand: Nat => hundred *' ten

def two-k: Nat => (suc (suc zero)) *' thousand

def four-k: Nat => (suc (suc zero)) *' two-k

def eight-k: Nat => (suc (suc zero      )) *' four-k

def sixteen-k: Nat => (suc (suc zero)) *' eight-k

def test (n: Nat): Nat => foldr (\a b => a + b) zero (map (\l => head l) (tails (gen n)))
