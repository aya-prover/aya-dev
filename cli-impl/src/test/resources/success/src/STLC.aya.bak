open import arith::nat
open import data::list::base
open import data::list::properties using (insert<=length, ++-!!-l, take<=length, take-!!)
open import data::maybe using (Maybe, just, nothing)
open import relation::nullary::decidable using (Decidable, because, reflect_true, reflect_false, if-then-else)
open import relation::binary::path using (= , refl, transport, <=>, pinv)
open import relation::binary::nat_cmp using (<=, <?)

open inductive Tm
| Lam Tm
| App Tm Tm
| Idx Nat
| True | False

open inductive Ty
| Arrow Ty Ty
| Bool

def Gamma : Type => List Ty

open inductive hasType Gamma Tm Ty
| Γ, Lam t, Arrow A B => Lam_hasType (hasType (A :< Γ) t B)
| Γ, App f a, B => App_hasType (A : Ty) (hasType Γ f (Arrow A B)) (hasType Γ a A)
| Γ, Idx n, A => Var_hasType (Γ !! n = just A)
| _, True, Bool => True_hasType
| _, False, Bool => False_hasType

// shift all de-bruijn index in [t] which is greater than or equal to [from] with [offset],
// this is required by instantiate a lambda or something that introduces binding.
// Not all index should be offset, for example, the usage of lambda parameter, so we introduce [from].
def shift (t : Tm) (from : Nat) : Tm elim t
| Lam l => Lam (shift l (suc from))
| App f a => App (shift f from) (shift a from)
| Idx i => if-then-else (subTrunc (suc i) from =? 0)   // i < from
    t
    (Idx (suc i))
| True => True
| False => False

def shift1 (t : Tm) : Tm => shift t 0

def inst (t : Tm) (i : Nat) (v : Tm) : Tm elim t
| Lam lam => Lam (inst lam (suc i) (shift1 v))
| App f a => App (inst f i v) (inst a i v)
| Idx j => if-then-else (i =? j) v t
| True => t
| False => t

def test-inst-0 : inst (Lam (Idx 0)) 0 True = Lam (Idx 0) => refl
def test-inst-1 : inst (Lam (Idx 1)) 0 True = Lam True => refl

def eval (t : Tm) : Tm
| App (Lam l) a => inst l 0 a
| _ => t

def test-eval-0 : eval (App (Lam (Idx 0)) True) = True => refl
def test-eval-1 : eval (App (Lam (Idx 1)) True) = (Idx 1) => refl

open inductive value (t : Tm)
| Lam _ => lamValue
| True => trueValue
| False => falseValue

// small step
open inductive infix —> Tm Tm
| App f a, App f' a' => S_App0 (a = a') (f —> f')
| App f a, App f' a' => S_App1 (f = f') (value f) (a —> a')
| App (Lam l) a, t => S_App (value a) (t = inst l 0 a)

def function_canoninal_form
  {Γ : Gamma} {t : Tm} (value t)
  {A B : Ty} (hasType Γ t (Arrow A B))
  : Sig (l : Tm) ** (t = Lam l)
| {_}, {Lam l}, lamValue, _ => (l, refl)
| trueValue, ()
| falseValue, ()

def shift_preservation
  {G : Gamma} {tm : Tm} {A : Ty} (hasType G tm A) (B : Ty) (i : Nat) (p : i <= length G)
  : hasType (take i G ++ [ B ] ++ drop i G) (shift tm i) A
| Lam_hasType lhT, C, _, _ => Lam_hasType (shift_preservation lhT C (suc i) p)
| App_hasType A' fhT ahT, C, _, _ => App_hasType A' (shift_preservation fhT C i p) (shift_preservation ahT C i p)
| True_hasType, _, _, _ => True_hasType
| False_hasType, _, _, _ => False_hasType
| {G}, {Idx n}, Var_hasType eqG, C, i, p =>
  match n <? i as b returns
    hasType (take i G ++ [ C ] ++ drop i G) (if-then-else b (Idx n) (Idx (suc n))) A {
  | _ because reflect_true n<i =>
    let
    | myGoal! : (take i G ++ (C :< drop i G)) !! n = (take i G) !! n := ++-!!-l n (take i G) _ (transport (fn l => subTrunc (suc n) l = 0) (pinv (take<=length _ _ p)) n<i)
    | myGoal!! : (take i G ++ (C :< drop i G)) !! n = G !! n := myGoal! <=> (pinv (take-!! _ _ _ p n<i))
    in Var_hasType (myGoal!! <=> eqG)
  | _ because reflect_false np => {??}
  }

def inst_preservation
  {G : Gamma} {tm : Tm} {A : Ty} (hasType G tm A)
  {v : Tm} {B : Ty} (hasType G v B)
  (i : Nat) (G !! i = just B)
  : hasType G (inst tm i v) A
// I need:
// * hasType (A :< G) (shift v 0) A
// * hasType G (inst l (suc i) (shift v 0)) B
// * inst_preservation lhT (?shT : hasType (A :< G) ?s B) (suc i) ((A :< G) !! (suc i) = just A)
//   : hasType (A :< G) (inst l (suc i) ?s) B
//
// I may have:
// * ?shT : hasType (A :< G) (shift v 0 1) B
| {_}, {Lam l}, Lam_hasType lhT, vhT, i, eqG => {?  ?}
| App_hasType A fhT ahT, vhT, i, eqG => {??}
| _, _, _, _ => {??}

def preservation
  {Γ : Gamma} {tm tm': Tm} {ty : Ty}
  (p : hasType Γ tm ty) (s : tm —> tm'): hasType Γ tm' ty
| App_hasType A fhT ahT, S_App0 eqa sf => App_hasType A (preservation fhT sf) (transport (fn a => hasType Γ a A) eqa ahT)
| {_}, {_}, {_}, {B}, App_hasType A fhT ahT, S_App1 eqf vf sa =>
  App_hasType A (transport (fn f => hasType Γ f (Arrow A B)) eqf fhT) (preservation ahT sa)
| App_hasType A fhT ahT, S_App va eqInst => {??}
