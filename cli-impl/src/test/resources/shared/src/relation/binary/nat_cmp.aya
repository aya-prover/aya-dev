open import arith::nat using (Nat, zero, suc, z≠s, subTrunc, =?, +)
open import arith::bool using (Bool, true, false)
open import relation::unary::negation using (neg)
open import relation::nullary::empty using (⊥, exfalso)
open import relation::binary::path
open import relation::nullary::decidable using (Decidable, yes, no, because, reflect_true, reflect_false, map as dec_map)
open import data::sum using (Sum, inl, inr)

def infix <= (a b : Nat) : Type => subTrunc a b = 0

def infix < (a b : Nat) : Type => (suc a) <= b

def infix >= (a b : Nat) : Type => subTrunc b a = 0

def infix > (a b : Nat) : Type => a >= (suc b)

def n<z→⊥ {n : Nat} (eq : n < 0) : ⊥ => exfalso (z≠s (pinv eq))

def s<s {a b : Nat} (p : suc a < suc b) : a < b => p
def s<=s {a b : Nat} (p : suc a <= suc b) : a <= b => p

def infix <=? (a b : Nat) : Decidable (a <= b) => subTrunc a b =? 0

def infix <? (a b : Nat) : Decidable (a < b) => (suc a) <=? b

def n<=z {n : Nat} (p : n <= 0) : n = 0 => p

def <=-case {a b : Nat} (a <= b) : Sum (a < b) (a = b) =>
  match a <? b {
  | _ because reflect_true p => inl p
  // a o- b = 0
  // suc a o- b != 0
  // suc a o- b = suc ?
  | _ because reflect_false np => match a =? b {
    | true because reflect_true p => inr p
    | false because reflect_false np => {??}
    }
  }

def a-b+b=a (a b : Nat) (p : b <= a) : subTrunc a b + b = a
| 0, _, _ => n<=z p
| suc a', 0, _ => refl
| suc a', suc b', _ => pmap suc (a-b+b=a a' b' (s<=s p))
