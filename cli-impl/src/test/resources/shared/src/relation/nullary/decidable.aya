open import relation::binary::path using (=, refl)
open import arith::bool using (Bool, true, false)
open import relation::unary::negation using (neg)

open inductive Reflect (P : Type) (b : Bool)
| _, true  => reflect_true P
| _, false => reflect_false (neg P)

open inductive Decidable (A : Type)
| infix because (does : Bool) (Reflect A does)

def yes {P : Type} (p : P) : Decidable P => true because (reflect_true p)
def no {P : Type} (np : neg P) : Decidable P => false because (reflect_false np)

def map {P Q : Type} (f : P -> Q) (g : Q -> P) (d : Decidable P) : Decidable Q elim d
| true because (reflect_true p) => yes (f p)
| false because (reflect_false np) => no (fn q => np (g q))
